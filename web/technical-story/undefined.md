# 배포용 서버 선택 과정

> 최종적으로 직접 서버를 구축한 이유와 그 과정에 대해 정리한 글이므로, 본 글을 참고하여 인프라를 구축하기에는 부적절합니다.



멈무 일기의 개발이 어느정도 진행이 되면서 개발용, 운영용 서버를 배포해야했다.

그 과정에서 고려한 주요 선택 기준과 최종적으로 <mark style="color:green;">**On-Premise**</mark>를 선택한 과정에 대해 정리해보았다.



## 🚣‍♀️ 배포용 서버 선택 기준

멈무일기를 배포하면서 서버를 고를 때 아래와 같은 기준으로 선택했다.

* **비용** : 당장은 수익화 모델이  없었기 때문에 매달 꾸준히 부과되는 **서버 비용**이 가장 큰 고민이였다.
* **편의성** : 인프라 구조에 수정이 발생해도 유연하게 수정이 가능하며, 삽질 시간을 줄이기 위해 레퍼런스가 충분해야한다.
* **고가용성** : 당연하게도, 365일 24시간 안정적으로 서버가 돌아가야한다.



이 중에 가장 중요한 기준은 **비용**이였다. 프로젝트의 인원이 모두 취준생이거나 대학생이며, 당장은 수익화 모델이 없었기 때문에 **비용**을 가장 큰 기준으로 삼았다.

두 번째로 편의성과 고가용성도 중요한 점 중 하나였다. 백엔드 개발 인원이 1명이였고, API와 명세서를 프론트로 전달하기 위해 빠른 배포가 필요했기 때문에 관련 레퍼런스가 충분히 존재해 배포에 어려움이 없고, 안정적인 서버가 필요했다.





## 1️⃣ Cloud Type

우선, **무료**로 제공되는 국내 클라우드 서비스인 <mark style="color:blue;">**Cloud Type**</mark>을 이용해 개발용, 배포용 서버를 구축했다.



### 1. Cloud Type이란?

{% embed url="https://cloudtype.io/" %}

<mark style="color:blue;">**Cloud Type**</mark>은 국내에서 런칭된 **컨테이너 기반 PaaS 클라우드 서비스**이다.



### **2. 특징**

* **컨테이너 기반 서비스**이기 때문에 컨테이너화가 가능한 일반적인 서버 소프트웨어를 구동하는 것에 큰 문제가 없지만, 컨테이너 기반인만큼 컨테이너화에 최적화된 **무상태(Stateless)기반의 소프트웨어 개발 및 운영에 가장 적합**하다
* **제한적인 무료**로 제공되어 간단한 프로젝트 배포를 하기에 적합하다.



{% hint style="danger" %}
**23.12.07**부로 구독 기능이 변경되었다.

기존에 제공하던 무료 리소스는 동일하지만, **매일 랜덤한 시간에 서버가 1회 종료**되도록 변경되었다.

따라서 운영용 서버로 사용하기에는 부적절하다고 판단했다.
{% endhint %}

{% embed url="https://help.cloudtype.io/pricing/2023-12-07" %}



<figure><img src="../../.gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>

위처럼 매일 랜덤한 시간에 서버가 중지된다.



### 3. 결론

위처럼 매일 한 번씩 수동으로 서버를 재구동해야하는 문제점이 있기 때문에 다른 클라우드 서비스로 마이그레이션해야했다. 매일 동일한 시간에 서버가 종료된다면 웹 크롤링 스크립트를 짜서 자동으로 재시동하는 방법도 생각해봤을 것인데, 랜덤한 시간이기 때문에 포기했다.





## 2️⃣ AWS

글의 서두에 언급햇듯이, 서버의 선택 기준은 아래와 같다.

* **비용**
* **편의성**
* **고가용성**&#x20;

<mark style="color:blue;">**Cloud Type**</mark>이 유료화가 됨에 따라 다양한 Managed Service를 제공해 **편의성**이 높은 <mark style="color:red;">**AWS**</mark>를 이용하기로 했다.&#x20;



### 1. ELB + EC2 + RDS

<figure><img src="../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

AWS를 이용하게 되면 위와 같은 구조로 구현할 예정이였다.

> 요청이 브라우저로부터 들어오면 Route 53은 요청을 받아서 해당 도메인에 대한 IP 주소를 반환한다. 그러나, 정적 리소스 요청의 경우 캐싱된 리소스가 CloudFront라는 CDN으로부터 바로 제공된다. 만약 CloudFront에 캐싱된 리소스가 없는 경우, 요청은 ELB (Elastic Load Balancer)를 통해 서버로 라우팅된다.
>
> 일반적으로 프로젝트에서는 읽기 작업이 80\~90%를 차지한다. 따라서, 읽기 작업의 부하를 분산하기 위해 RDS에서는 Replica auto scaling을 적용해 읽기 작업을 위한 DB 복제본이 자동으로 생성되고 관리된다.&#x20;



당장 프로젝트를 위 구조로 배포해도 큰 문제는 없어 보였다. 하지만 각각의 인스턴스에 대한 비용이 어마무시하게 나올 것으로 예상하여 Serverless를 고려해보았다. ~~실제로 한 개발자 분은 EC2 + RDS로 토이프로젝트를 배포했다가 11만원이 과금됐다고 한다...~~



### 2. Lambda + DynamoDB

**Serverless Service**인 lambda와 DynamoDB에 대해 고려해보았다.

&#x20;

우선 **Serverless란?**

Serverless는 실제 Server가 없는 것은 아니고, 인프라(서버)의 존재를 모르는 상태에서 서비스를 사용할 수 있다는 의미로 사용되는 용어이다.



EC2나 RDS 같은 경우 미리 지정한 용량, 성능의 서버용 컴퓨터를 대여해 해당 성능만큼의 비용을 지불하게 된다. 하지만 Serverless는 말그대로 서버를 대여하는 것이 아니라 인프라에 대한 관리는 <mark style="color:red;">**AWS**</mark>가 담당하고 실제 요청이 발생하면 함수를 실행하여 요청 내부적으로 처리한다.



**장점은 다음과 같다.**

* 노는 자원이 없이 실제 사용한 만큼만 과금된다.
* 개발자가 서버에 대한 관리를 하지 않아도 된다.

본인의 서버 선택 기준인 **비용**, **편의성**, **고가용성**을 모두 만족하기 때문에 선택하지 않을 이유가 없었다.



실제 서비스를 구성한다면 아래와 같다.

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

모든 서비스가 Serverless이기 때문에 실제 발생하는 요청만큼만 비용이 청구된다.&#x20;

다만, 지금 개발하고 있는 프로젝트가 Spring Boot로 개발이 어느정도 완성된 상태였고 아래에 언급한 **Cold Start**라는 문제가 존재해서 선택하지 않았다.



### 3. Cold start 문제

Cold start는 serverless 환경에서 함수가 처음 호출될 때 발생하는 지연 현상을 말한다.&#x20;

serverless 플랫폼에서는 함수가 호출되면 해당 함수를 실행할 수 있는 컨테이너가 초기화되어야 하며 이 초기화 과정은 함수가 호출될 때마다 발생할 수 있다.



Spring Boot를 Lambda에 적용하기 위해서는 **Cold Start**라는 것을 해결해야한다.

Spring Boot로 만든 프로젝트는 부트스트랩 과정이 길기 때문에 최초로 들어온 첫 요청에 대한 응답 시간이 오래 걸린다.



이를 해결하기 위해서는

1. Spring 프레임워크를 제거해 Java만을 이용해 개발한다. [https://docs.aws.amazon.com/ko\_kr/lambda/latest/dg/java-samples.html](https://docs.aws.amazon.com/ko\_kr/lambda/latest/dg/java-samples.html)
2. Spring 프레임워크를 이용하되, 초기 로딩 속도를 올리기 위한 튜닝을 한다.



개발 초기 단계였다면 Lambda에 적합한 프레임워크나 언어를 선택했을 것이다. 하지만 이미 Spring으로 개발이 어느정도 진행된 상황이였다.&#x20;

추가적으로, 단지 비용을 줄이기 위해(물론 중요한 부분이긴 하다) 기존 서비스에 Lambda관련 코드가 추가되는 것이나, 프레임워크를 튜닝하는 것이 개발 효율상 좋지 못하다고 판단했다. 따라서 Serverless를 위해 Lambda를 통한 배포는 선택하지 않았다.



추후 Node.js나 Python을 통해 서버 개발을 할 기회가 생긴다면 Lambda를 통해 배포해고 싶긴하다. DynamoDB도 이용해 완전한 Serverless를 구현해보는 것도 경험해보면 MSA 환경 구축을 간편하게 할 수 있다고 해서 경험해보고 싶다.



### 4. 결론

AWS는 레퍼런스도 충분하고, managed service이기 때문에 많은 기능이 이미 구현되어 있어 개발도 용이하다. 예를 들어, RDB Replication이나 Scale Up같은 경우도 버튼 클릭 몇번만으로 간단하게 추가할 수 있고,  ELS는 예키치 못하게 종료되도 <mark style="color:red;">**AWS**</mark>가 알아서 재시동해서 고가용성을 지킬 수 있다.&#x20;



<mark style="color:red;">**AWS**</mark>는 분명 개발도 용이하고 다양한 기능을 제공하는 잘 만들어진 플랫폼이다. 하지만 모든 기능이 **유료**이며, 서비스를 확장할수록 예상치 못한 과금이 발생할 수 있으므로 주의가 필요하다.



계속해서 언급하는 **비용** 문제 때문에 <mark style="color:red;">**AWS**</mark>를 자유롭게 활용하지 못할 것 같아 최종적으로는 <mark style="color:green;">**On-Premise**</mark> 서버를 구축했다.





## 3️⃣ On-Premise

<mark style="color:red;">**AWS**</mark>의 구조와 배포에 대해 고민을 오래 하면서, 이정도면 직접 구현할만한데? 라는 생각에 집에서 놀고 있던 노트북에 Ubuntu를 설치해 직접 서버를 구현해보기로 했다.



### 1. Ubuntu

서버를 구축하기 위해 리눅스 배포판 중 **Ubuntu**를 선택했다.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Desktop
* Server
* IoT
* Cloud

다운로드 탭을 보면 위 네 개의 Ubuntu 버전이 존재한다. 넷의 차이는 초기 설치되는 패키지의 차이이다.&#x20;

* 가장 적게 설치되는 것이 Ubuntu Server이다.&#x20;
* Desktop은 GUI와 필수 응용 프로그램이 추가되어 있다.
* Cloud는 AWS나 GCP와 같은 엔터프라이즈급 클라우드를 구축하기 쉽게 해주는 패키지라고 설명에 적혀있다. 현재 프로젝트의 규모가 기업급은 아니기 때문에 제외했다.
* Desktop과 Server는 커널은 동일하며 어차피 SSH를 통해 원격으로만 개발 할 예정이기 때문에 가벼운 Server로 설치했다. 참고로 언제든 운영 중에 변경이 가능하다.



### 2. 무중단 배포

<mark style="color:blue;">**CloudType**</mark>은 컨테이너 기반 서비스이기 때문에 jar파일만 배포해도 컨테이너를 통한 무중단배포가 가능하다.

<mark style="color:red;">AWS</mark>의 EC2는 Elastic IP나 ELB API 등을 통해 무중단 배포가 가능하다.

하지만, PaaS같은 Managed Service를 이용하는 것이 아닌, 자체적으로 서버를 구현했기 때문에 직접 무중단 배포를 구현해야 했다.



따라서 Docker-compose를 이용해 두 개의 컨테이너를 통한 Blue/Green방식의 무중단 배포를 구현했다.

Blue/Green방식의 무중단 배포는 배포 프로세스를 자동화하기 쉬워, 빠르고 안정적인 배포가 가능하다는 장점이 있지만, 무중단 배포를 위해 두 개의 동일한 환경을 유지해야 하므로 순간적으로 리소스 소모가 커질 수 있다. 성능이 꽤 괜찮은 개인 노트북을 통해 서버를 구축했기 때문에 이정도 리소스는 충분히 감당가능했다.



### 3. Public IP

다음으로 집에서 서버를 구축할 때 가장 걸림돌이 되는 것이 공인 IP이다.

사설 IP의 경우 고정할 수 있으나 할당된 공인 IP를 계속해서 이용하기 위해서는 비용을 지불해야한다.



이것을 해결하기 위해 **DDNS(Dynamic DNS)**를 적용할 수 있다.

> **DDNS**는 동적 IP 주소를 가진 네트워크 장치를 인터넷 상에서 정적인 도메인 이름으로 연결할 수 있도록 도와주는 서비스이다.



일반적으로 인터넷 서비스 제공자(ISP)로부터 동적으로 할당되는 IP 주소는 모뎀을 껐다 키거나 일정 주기 이후에 변경될 수 있다. 변경될 때마다 **DNS**에 변경된 동적 IP를 명시하는 것은 귀찮은 작업이다.

**DDNS**를 사용하면 동적 IP 주소의 변경을 감지하고, 변경된 IP 주소와 도메인 이름을 연결하여 항상 최신 IP 주소로 네트워크 장치에 접근할 수 있다.



공유기를 이용한다면 **DDNS**를 지원하는지 확인해보고 간편하게 적용할 수 있다. 지금 사용하고 있는 Iptime같은 경우 타 공유기와는 다르게 **DDNS**를 무료로 제공하고 있다. 설정이후에는 동적 IP 주소가 변경되더라도 **DDNS** 서비스가 자동으로 변경된 IP 주소를 감지하고 도메인 이름을 업데이트하여 항상 최신 IP 주소로 네트워크 장치에 접근할 수 있게 된다.





### 4. 최종 배포 구조도

<figure><img src="../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

하나의 Ubuntu Server안에 모든 서비스를 구축해서 배포 중이다.

집에서 배포하고 있으므로 모뎀이나 컴퓨터가 종료되면 배포도 중단된다는 단점이 있지만 백수라 거의 집에만 있으므로... 큰 상관이 없다... ㅠㅠ 🙀





### 5. 결론

배포용 서버를 선택하면서 비용을 줄이기 위해 다양한 것들을 고려해보면서 직접 서버를 구현하는 것도 별로 어려운 것이 아니라는 것을 알게 되었다.



추후 비용적인 부분이 해결된다면 편의성이 가장 좋은 <mark style="color:red;">**AWS**</mark>만을 이용해 서비스를 개발하고 배포해보고 싶다!



