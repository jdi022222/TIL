---
description: 스프링 입문을 위한 자바 객체지향의 원리와 이해를 읽고 정리한 문서입니다.
---

# 객체지향의 원리와 이해

## 01 사람을 사랑한 기술

### 언어의 발전 과정

* 2GHz → 1초에 전구를 20억번 껏다 켤 수 있다
  * 인간은 2진수, 10진수, 16진수를 이해할 수 있으나 컴퓨터의 속도보단 느리다
* 기계어 → 어셈블리어 → C 언어
  * 기계어 : 0, 1, 기종에 종속 O
  * 어셈블리어 : 일상 단어 사용, 기종에 종속 O
  * C 언어 : 수학적 기호 사용, 기종에 종속 X



C 언어의 이식성

* C언어의 int는 운영체제별로 크기가 다르다

{% hint style="info" %}
ANSI/ISO C 표준 : **short** should be at least 16bits and **long** should be at least as long as int, but not smaller than 32 bits.
{% endhint %}

* 결국, 어셈블리어보다는 이식성이 좋으나 Java만큼은 아니다
* **One Source Mulit Object Use Anywhere △**



C++의 등장

* C에 객체 지향 개념을 도입
  * 3 장에 나옴
* **One Source Mulit Object Use Anywhere O**



Java - 진정한 객체 지향 언어

* C++은 객체 없는 프로그래밍도 가능하므로 **객체 지원 언어**
* 기종별 컴파일러가 필요한 C와는 달리 하나의 컴파일러만 필요 (JRE 세팅은 필요)
* **Write Once Use Anywhere** ← **Virtual Machine**을 통해



스프링

* 스프링 = **OOP Framework With IoC, DI, AOP, PSA, ORM, JPA, Schedule, …. on POJO, SOLID, OOP Design Patterns**
* 스프링의 삼각형 : POJO에 세 가지 유형을 추가 → IoC/DI, AOP, PSA (Portable Service Abstraction; 일관성 있는 서비스 추상화)





***

## 02 자바와 절차적/구조적 프로그래밍

모든 프로그래밍 언어가 공통적으로 메모리를 사용하는 방식

* 코드 실행 영역 + 데이터 저장 영역 (Static, Stack, Heap)



Java에 존재하는 절차적 + 구조적 프로그래밍의 유산

* 절차적 프로그래밍 = goto를 쓰지 말라
  * Java도 그 폐해를 생각해 goto를 사용 못하도록 not Used 예약어
    * const도 final로 대신하고 있기 때문에 not Used 예약어
  * goto를 사용하면 프로그램 실행 순서가 복잡해진다
* 구조적 프로그래밍 = 함수(메서드)를 이용해 중복 코드를 한 곳에서 관리



### JAVA 메모리 구조

* 스태틱 : 클래스들의 놀이터
* 스택 : 메서드들의 놀이터
* 힙 : 객체들의 놀이터



### main() 실행 과정

```java
public class Test {
	public static void main(String[] args) {
		int i = 10;
		int k = 20;
		
		if(i == 10) {
			int m = k + 5;
			k = m;
		} else {
			int p = k + 10;
			k = p;
		}
	}
}	
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b199294-0be4-47b6-b1b5-eb87d6e20a20/5ab4b86d-b27d-40b6-bf90-59a620734dbb/Untitled.png)

1. 스태틱 영역에 java.lang 패키지 추가 (모든 자바 프로그램의 필수 패키지)
2. 스태틱 영역에 개발자가 작성한 모든 클래스와 임포트 패키지 추가
3. 스택 영역에 main()의 스택 프레임이 할당 (정확히는 클래스를 제외한 여는 중괄호를 만날 때마다)
   1. 내부에 if문의 여는 중괄호가 있으면 내부 중첩 스택 프레임이 추가 생성
4. 스택 프레임에 메서드의 인자를 저장할 args 할당
5. 실행
6. 닫는 중괄호를 만나면 스택 프레임 소멸



**지역 변수**; 스택 프레임 안의 변수



### **전역 변수**를 사용하지 말라

1. 프로젝트 규모가 커지면 메모리를 추적하거나 디버깅하지 않는 이상 값 파악하기 어렵다
2. 다른 메서드에 의해 변경된다면 그 부분을 추적해 들어가야만 한다 (실무에서는 수만 줄)
3. 멀티 스레드 프로그램에서도 문제가 된다
4. 전역 상수는 추천한다



멀티스레드

* 스택 영역을 스레드 개수만큼 분할해서 사용
* 공통된 T메모리에서 스택 영역만 분리하므로 멀티 프로세스보다 메모리 적게 사용
* 요청당 스레드(servlet)가 요청당 프로세스(CGI) 보다 효율적인 이유이다.
*   **이러한 멀티스레드 환경에서 전역 변수를 사용한다면 정합성이 깨질 수 있다.**

    * 락을 사용하면 되지만 멀티 스레드의 장점이 감소





***

## 03 자바와 객체 지향

### **객체지향?**

기존 구조적 프로그래밍 언어에서 가장 중요한 것은 “함수”

* 코드를 논리적인 단위로 Divide And Conquer
* 중복 제거 + 논리의 분할



함수로 인해 프로그래밍이 편해지면서 파격적인 제안 발생

“우리가 눈으로 보고, 느끼고, 생활하는 현실 세계처럼 프로그래밍할 수는 없을까?”

→ **객체 지향**의 개념의 탄생



우주 만물은 객체의 합으로 이루어져 있다.

* 객체; 세상에 존재하는 사물
* 속성; 프로퍼티, 속성값
* 행위; 메서드

> 클래스는 분류에 대한 개념이며 실체가 아니다. 객체는 실체다. 클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아



### **객체 지향의 4대 특성**

**캡슐화; 정보 은닉**

* 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
* 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
* aaa.jar파일 안에 있는 Package1의 public, protected, default는 bbb.jar파일 안의 Package2에서 접근 가능하다. ← 보안 문제 고민



**Call By Reference vs Call By Value**

Call By Reference는 최신 언어에서는 더이상 사용되지 않고 통합한 방식으로 사용되고 있다. 즉, 구분이 크게 의미가 없으며 기본적으로 큰 차이가 없다.

둘의 차이는 값을 복사할 때 값을 그 자체로 해석하느냐, 주소값으로 해석하느냐의 차이다. Java는 Call By Value를 기본으로 채택하고 있다.

[https://deveric.tistory.com/92](https://deveric.tistory.com/92)



**상속화; 재사용, 확장**

> 상속은 재사용 + 확장이다.

**오해 1**; 상속이라는 의미

상속은 영단어를 그대로 번역하며 생긴 오해이다. (할아버지 → 아버지 → 아들)

객체지향의 상속은 **재사용**과 **확장**으로 이해하는 것이 맞다. (동물 → 포유류 → 고래)

상속 과정에서 반드시 만족해야 할 문장이 있다.

**“하위 클래스는 상위 클래스다.”**

* 아버지는 할아버지다? 아들은 아버지다? ← 이상하다.
* 포유류는 동물이다. 고래는 포유류다. ← 자연스럽다.



**오해 2**; 상속은 is a 관계

펭귄 is a 동물 ← 펭귄은 동물이다 or 펭귄은 한 마리 동물이다.

단수 명사 앞에 a를 붙여 그 부류를 통칭할 수도 있으나, 위처럼 하나의 개체로 표현될 여지가 있다.

오해가 없도록 **is a kind of**로 표현한다.



**다중상속**

인어는 사람과 물고기 모두를 상속받을 수 있다.

사람은 걸을 수 있지만, 물고기는 헤엄칠 수 있다. ← 다중 상속의 **다이아몬드 문제** 발생

따라서 Java는 다중상속을 지원하지 않는다.

대신, C++에는 없는 인터페이스를 도입해 다중 상속의 득을 취했다.



**인터페이스**

**is able to**로 표현된다.

즉, 무엇을 할 수 있는 이라는 표현 형태로 사용된다.

* Runnable; 실행할 수 있는
* Serializable; 직렬화할 수 있는



**특성이 많을 수록 좋을까?**

상위 클래스는 물려줄 특성이 많을수록 좋다. ← **LSP**

인터페이스는 구현을 강제할 메서드가 적을 수록 좋다. ← **ISP**



**서브 클래스 생성시 T메모리 구조**

서브 클래스를 만들경우 힙 영역에 슈퍼 클래스의 인스턴스도 함께 생긴다.

사실, Object 클래스의 인스턴스도 함께 생성된다.

*   형 변환

    ```java
    public class Main {

    	public static void main(String[] args) {
    		SuperClass var = new SubClass();
    		var.print();
    	}
    }

    class SuperClass {
    	void print() {
    		System.out.println("Super");
    	}
    }

    class SubClass extends SuperClass {

    	@Override
    	void print() {
    		System.out.println("Sub");
    	}

    	void test() {
    		System.out.println("Test");
    	}
    }
    ```

    * Sub 출력, Test는 호출 불가
    * 동적 바인딩(Dynamic Binding) 은 실행시에 성격이 결정되고 정적 바인딩(Static Binding) 은 컴파일시에 성격이 결정 → static은 동적 바인딩 불가



추상화; 모델링

> 객체 지향의 추상화는 곧 모델링이다.

**Object**; 물건, 물체

**개체**; 독립된 존재. 독립적인 기능을 가지고 있음

→ 따라서 Object는 사실 **객체**보다는 **개체**라는 표현이 맞다

* 객체 지향의 객체는 “세상에 존재하는 유일무이한 사물”로 재정의할 수 있다.
* 클래스는 “분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념”



현실 세계의 사람을 UML 클래스 다이어그램을 통해 표현한다면? 수십만 페이지도 부족할 것이다.

근데 그럴 필요가 있을까? → 여기서 애플리케이션 경계(= 컨텍스트)라는 개념이 등장한다. 아래의 물음에 답해보자.

> 내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?

사람이라는 클래스는 병원 애플리케이션에서는 <직업, 연봉> 특성이 필요없으며, 은행 애플리케이션은 <키, 몸무게>는 필요없지만 <직업, 연봉>은 필요하다.



결국 추상화란, 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합 하는 모델링이다.



👌 **추상화 = 모델링 = 자바의 Class 키워드**



**다형성; 사용편의성**

> 오버라이딩과 오버라이딩



## 04 자바가 확장한 객체 지향

**abstract**

* 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다.
* 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제
* 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.



**생성자**

* 생성자로 줄여서 부르지만 정확하게는 객체 생성자 메서드이다.



**static 블록**

```java
class Test {
	static {
		// 클래스가 스태틱 영역에 배치될 때 실행되는 코드
	}
}
```

* 실제로는, 해당 패키지 또는 클래스가 처음으로 사용될 때 static 영역에 배치된다.
* 따라서 위 클래스를 호출하거나 생성하지 않는다면 static 블록은 실행되지 않는다.
* 여러번 객체를 만들어도 **단 한 번만** 실행된다.



**instanceof**

* instanceof는 강력하지만 LSP를 어기는 코드에서 주로 나타나는 연산자이다.



**interface**

* public abstract, public static final을 자동으로 붙여준다. 명시적으로 나타내는 것도 좋다.



**this**

* 지역 변수와 속성의 이름이 같은 경우 지역 변수가 우선
* 객체 변수와 이름이 같은 지역 변수가 있는 경우 this로 객체 변수 사용 가능
* 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 클래스명을 접두사로 사용



**메서드와 메모리**

```java
SuperClass a = new SuperClaee();

a.test();
```

만약, 객체를 1000개를 만들고 각각 test()라는 메서드를 실행한다고 했을 때 1000개의 객체별로 힙 영역에 1000개의 메서드도 생성된다. 그런데 객체 멤버 메서드는 각 객체별로 달라지는 것이 아니므로 JVM은 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나만 보유한다.

그리고, 눈에 보이지는 않지만 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.

따라서 아래와 같이 변경된다고 생각하면 된다. (실제로 코드 자체가 아래처럼 변경은 X)

```java
SuperClass a = new SuperClaee();

SuperClass.test(a);
```



