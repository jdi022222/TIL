# 동기화, 상호 배제, 모니터

## 프로세스와 스레드

### 1. 프로세스

> 운영체제로부터 시스템 자원을 할당받아 메모리에서 실행되고 있는 프로그램의 인스턴스



프로세스는 한정된 시간 만큼 CPU를 이용하며 타이머 인터럽트 발생시 다른 프로세스가 실행된다.

프로세스의 상태는 커널 영역에 생성되는 PCB가 관리한다.



### 2. 스레드

> 하나의 프로세스 내에서 실행되는 흐름의 단위

하나의 프로세스만으로는 하나의 프로그램을 동시에 여러 기능을 실행하기 어렵다.

하나의 프로세스를 여러 스레드로 구성하여 여러 기능을 동시에 실행할 수 있다.



여러 스레드는 하나의 프로세스 내에 존재하며 코드, 데이터, 힙 자원은 공유하며 각 스레드는 각가의 스택 영역을 가진다.

<figure><img src="../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>



## ？ 동시 접근 문제

### 1. 경쟁 상태

여러 프로세스/스레드가 **동시에 하나의 데이터**를 접근한다면? -> 해당 하는 값의 무결성이 깨지거나 의도치 않은 결과가 일어날 수 있다.&#x20;

<figure><img src="../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

각 프로세스는 다른 프로세스의 존재 여부를 모르고 있다는 가정하에 **프로세스1**과 **프로세스2**가 **동시에** 변수 a를 1씩 증가시키고 있다고 가정해보자.&#x20;



<figure><img src="../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

프로세스1의 입장에서는 a는 1이 되어야 하지만 처리하는 과정에서 프로세스2 또한 해당 값을 증가시키기 때문에 2가 반환될 수 있다.&#x20;

만약, 위처럼 단순한 변수 값이 아니라 결제 금액이나 포인트 같은 민감한 데이터일 경우에는 큰 문제가 발생할 수 있다.



<figure><img src="../.gitbook/assets/image (36).png" alt=""><figcaption></figcaption></figure>

위 예시처럼 여러 프로세스/스레드가 공유 자원을 접근하는 영역을 코드 영역을 <mark style="color:red;">**임계 영역**</mark>이라고 하며 접근 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황을 <mark style="color:red;">**경쟁 조건**</mark>이라고 한다.



> **임계 영역 critical section**
>
> 여러 프로세스/스레드가 공유 데이터를 접근하는 프로그램 코드 부분을 의미한다.



> **경쟁 조건 race condition**
>
> 여러 프로세스/스레드가 공유 데이터를 접근할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황을 의미한다.



### 2. 동기화

위처럼 경쟁 조건 때문에 의도치 않은 동작을 예방하기 위해 프로세스/스레드 간의 **동기화(Synchronization)**를 해야한다.  즉, **동기화**는 <mark style="background-color:purple;">프로세스/스레드 들이 서로 동작을 맞춰보거나 정보를 공유하는 것</mark>을 의미한다.



반대로, **비동기(Asynchronous)**는 프로세스/스레드 들이 서로의 존재에 대해 모르는 것을 의미한다.



### 3. 상호 배제

동기화는 **상호 배제(Mutual Exclusion)** 매커니즘을 통해 구현된다.

**상호 배제**는 <mark style="background-color:purple;">둘 이상의 프로세스/스레드가 동시에 임계 영역에 접근하는 것을 막는 것</mark>을 의미한다.

**상호 배제** 매커니즘을 활용하면 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지할 수 있다.



상호 배제 적용 후를 살펴보기 위해 아까 봤던 예시를 기계어 명령으로 다시 살펴보자.

두 개의 프로세스를 통해 a라는 변수를 1씩 증가시켜 2로 만드는 과정이다.



<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>



우선, 기계어 명령은, `Atomicity`와 `Indivisible`한 특성을 가지고 있다. 따라서 한 기계어 명령의 실행 도중에 다른 명령어에 의해 인터럽트 받지 않게 된다.&#x20;

이 말인 즉슨, 하나의 프로세스 내에서 실행되는 명령어가 끝나기 전에, 다른 프로세스에서 명령어가 실행되더라도 중단되지 않아 **경쟁 조건**이 발생할 수 있다는 의미이다.



**만약, 1->2->4->5->3->6 순서로 실행이 된다면?**

* 레지스터  R1과 레지스터 R2에는 1이라는 값이 저장되어 있기 때문에 a에 대해 `+ 1` 연산을 두 번 수행했음에도, 1이라는값이 저장되게 된다.
* 처리 결과에 대해 의도치 않은 동작이 발생된다.



따라서 위 상황을 해결하기 위해 **상호 배제를 적용**해보면, 프로세스 1의 임계 영역이 먼저 실행되고 종료가 된 후에 프로세스 2가 실행되게 된다.

**따라서, 1->2->3->4->5->6 순서로 실행이 된다면?**

* 레지스터  R1에는 1이 저장되고 프로세스 1이 종료되면서 a에는 1이 저장된다.
* 레지스터  R2에는 2가 저장되고 프로세스 2이 종료되면서 a에는 2이 저장된다.



예시처럼, 상호 배제를 적용해 동시에 임계 영역에 접근을 막음으로써, 프로세스/스레드간의 순서가 보장되는 동기화 기법이 적용됨을 볼 수 있었다.



## 👍 상호 배제 방법

* SW적인 방법
  * Dekker's algorithm
  * Dijkstra's algorithm
* HW적인 방법
  * TestAndSet instruction
* OS가 제공하는 방법
  * SpinLock
  * Semaphore
  * Mutex
  * Eventcount/sequencer
* Language-level 방법
  * Monitor



이 외에도 다양한 방법이 있다. OS가 제공하는 방법과 모니터만 정리해보았다.



동기화/상호배제는 기본적으로 **락**(Lock)을 이용한다. 하나의 프로세스/스레드가 자원에 접근하면 해당 자원을 잠금(= 락)을 하고 사용이 끝나면 잠금을 해제하는 방식으로 구현된다.&#x20;



### 1. 스핀락

* 락을 가질 수 있을 때까지 반복해서 시도하는 방법



스핀락은 정수형 변수 S를 P, V 연산으로 접근하여 임계 영역을 실행하는 방법이다.



<figure><img src="../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>



* 변수 S :  0일 경우 active 상태로, 임계 영역을 실행 중인 프로세스가 있음을 의미하며 다른 프로세스가 접근 불가능한 상태이다. 반대로 1 이상일 경우 임계 영역을 실행 중인 프로세스가 없음을 나타낸다.
* P 연산 : 프로세스가 임계 영역에 진입하는 연산. S 값을 1 감소한다. wait라고도 한다.
* V 연산 : 프로세스가 임계 영역을 빠져나가는 연산. S 값을 1 증가한다. signal이라도고 한다.



스핀락은 두 가지 문제가 있다.

#### 문제점 1. 바쁜 대기 문제

스핀락은 프로세스/스레드가 락을 기다리는 동안 CPU를 계속해서 낭비한다는 단점이 있다.

단순히 락을 획득하기 위해 지속해서 CPU 자원이 소모되기 때문에 이를 **바쁜 대기**(Busy Waiting)문제라고 한다.

**물론, 락을 점유하는 시간이 굉장히 짧다면 유용할 수도 있다.**



#### 문제점 2. 멀티 프로세서 시스템에서만 사용 가능

임계 영역을 실행하기 위한 프로세스가 P 연산을 계속해서 수행해야 하기 때문에 멀티 프로세서 시스템에서만 사용 가능하다.



### **2. 뮤텍스 MUTual EXclusion**

* 스핀락의 **바쁜 대기** 문제를 해결한 방식이다.
* 동기화 대상이 1개일 때 사용한다.



스레드는 Key(lock)를 가지며 해당 Key를 가진 스레드만이 공유 자원에 접근할 수 있다.

다른 스레드는 sleep 상태로 자원 점유를 위해 대기한다.



<figure><img src="../.gitbook/assets/image (38).png" alt=""><figcaption></figcaption></figure>

* lock :  true일 경우 해당 자원에 접근하는 다른 프로세스/스레드는 대기 큐로 적재된다.&#x20;
* acquire 연산 : 프로세스가 임계 영역에 진입하는 연산. lock을 건다.
* release 연산 : 프로세스가 임계 영역을 빠져나가는 연산. lock을 해제한다.



바쁜 대기 현상은 사라졌으나 임계 영역에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝난다면 스핀락이 오히려 뮤텍스보다 더 이득일 수도 있다.



### **3. 세마포어 Semaphore**

* 스핀락의 **바쁜 대기** 문제를 해결한 방식이다.
* 동기화 대상이 1개 이상일 때 사용한다.&#x20;



스핀락과 마찬가지로 **세마포어**라는 **정수 변수**를 이용해 임계 영역에 몇 개의 프로세스가 진입 가능한지 나타낸다.

P 연산과 V연산으로 해당 **정수 변수**를 이용한다.



* 변수 S :  0일 경우 active 상태로, 임계 영역을 실행 중인 프로세스가 있음을 의미하며 다른 프로세스가 접근 불가능한 상태이다. 반대로 1 이상일 경우 임계 영역을 실행 중인 프로세스가 없음을 나타낸다.
* P 연산 : 프로세스가 임계 영역에 진입하는 연산. S 값을 1 감소한다.
* V 연산 : 프로세스가 임계 영역을 빠져나가는 연산. S 값을 1 증가한다.



#### 3-1. 바쁜 대기 문제 해결

<mark style="background-color:purple;">스핀락과의 차이점은 S 변수 하나에 ready queue 하나가 할당된다는 점이다.</mark>

임계 영역에 진입하지 못한 프로세스는 지속적으로 P 연산을 수행하는 것이 아니라 S 변수의 waiting queue에 적재 후 자원에 대한 잠금이 해제되면 대기중인 프로세스를 ready queue에 적재하여 CPU 자원을 할당받을 수 있도록 한다. -> **바쁜 대기 문제**가 해결된다.

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

#### 3-2. 순서 보장

멀티 코어 환경일 경우 세마포어는 호출 순서를 정해줄 수 있다.



* 프로세스들간의 실행 순서를 맞추기 위해서는 어떻게 해야할까?&#x20;
* 프로세스 1이 프로세스 2보다 선행되어야 하는 작업이라면 어떻게 해야할까?



세마포어를 이용하면 간단하게 순서를 보장할 수 있다.

<figure><img src="../.gitbook/assets/image (40).png" alt=""><figcaption></figcaption></figure>

1. S를 0으로 초기화한다.
2. 프로세스 1은 P 연산이 없으므로 바로 임계영역이 실행된다. 프로세스 2는 S가 0이므로 대기 큐에 적재된다.
3. 프로세스 1이 종료될 경우 S를 1로 증가시키며 대기하고 있던 프로세스 2가 CPU 자원을 할당받아 실행된다.



#### 종류 1. 바이너리 세마포어 Binary Semaphore (vs 뮤텍스)

S가 0과 1로 두 종류의 값만 가지는 세마포어이다. 상호 배제와 프로세스 동기화 목적으로 사용한다.



#### 종류 2. 카운팅 세마포어 Counting Semaphore

S가 0 이상의 값을 가지는 경우이다. Producer-Consumer 문제를 해결하기 위해 사용한다.



하지만 세마포어도 단점을 가지고 있다.

1. 매번 임계 구역 전후로 P와 V 연산을 호출해야한다.
2. 누락되거나 호출 순서가 섞인 경우 예상치 못한 결과가 발생할 수 있다.



### **3. 모니터 Monitor**

동시성을 보다 간편하고 안전하게 다루기 위해 만들어진 language-level의 **추상화**된 동기화 도구이다.

추상화되었기 때문에 위의 low-level 매커니즘보다 사용이 간편하다.



뮤텍스와 마찬가지로 동기화 대상이 1개일 때 사용한다.



**뮤텍스와의 다른 점**은 뮤텍스는 다른 프로세스간의 동기화 시 이용되며 모니터는 하나의 프로세스 내에서 다른 스레드 간의 동기화에 사용된다.&#x20;



**세마포어와의 다른 점**은 세마포어는 카운터라는 변수값으로 상호배제를 적용하지만 모니터는 이러한 기능이 캡슐화되어 있는 기술이기 때문에 `synchronized`, `wait` 등의 키워드로 상호 배제를 적용할 수 있다.



### 4. 정리

| 특성       | 스핀락 (Spinlock)       | 뮤텍스 (Mutex)          | 세마포어 (Semaphore)     | 모니터 (Monitor)        |
| -------- | -------------------- | -------------------- | -------------------- | -------------------- |
| 동기화 메커니즘 | 상호배제                 | 상호배제                 | 상호배제 및 조건 변수         | 상호배제 및 조건 변수         |
| 대기 방식    | 바쁜 대기 (Busy waiting) | 대기 큐 (Waiting queue) | 대기 큐 (Waiting queue) | 대기 큐 (Waiting queue) |
| 복잡성      | 낮음                   | 중간                   | 중간                   | 중간                   |
| 사용 편의성   | 높음                   | 높음                   | 중간                   | 높음                   |
| 대상       | 프로세스/스레드             | 프로세스/스레드             | 프로세스/스레드             | 모듈/클래스               |
| 자원 낭비    | 높음                   | 낮음                   | 낮음                   | 낮음                   |
| 경쟁 조건 방지 | O                    | O                    | O                    | O                    |
| 재진입 가능   | X                    | O                    | O                    | O                    |

* 세마포어는 뮤텍스가 될 수 있으나, 뮤텍스는 세마포어가 될 수 없다.
* 세마포어는 데이터 소유가 불가능하지만, 뮤텍스는 자원을 소유하며 책임을 가진다.



## 🖥️ 모니터 - 작성 중

모니터를 조금 더 자세하게 살펴보겠다.



기능

* 상호 배제(mutual exclusion)를 보장
* 조건에 따라 Thread가 대기 상태로 전환 가능



언제 사용?

* 한 번에 하나의 스레드만 실행해야 할 때
* 여러 스레드와 협업이 필요할 때&#x20;



구성 요소

1. mutex : critical section에서 mutual exclusion을 보장하는 장치, mutex lock을 취득하지 못한 스레드는 큐에 들어간 후 대기 상태로 전환(waiting queue). 즉, mutext lock을 쥐고 있는 스레드가 lock을 반환하면 락을 기다리며 큐에 대기 상태로 있던 스레드 중 하나가 실행됨
2.  condition variable : waiting queue를 가짐. 조건이 충족되길 기다리는 스레드들이 대기 상태로 머무는 곳





condition variable 주요 동작

wait : thread가 자기 자신을 condition variable의 waiting queue에 넣고, 대기 상태로 전환

signal : waiting queue에서 대기 중인 스레드 중 **하나**를 깨움

broadcast : waiting queue에서 대기 중인 스레드 중 **전부**를 깨움



<figure><img src="../.gitbook/assets/image (37).png" alt=""><figcaption></figcaption></figure>

mutex lock을 취득하지 못한 스레드는 entry queue로 들어가서 대기하게 된다.

노란색 부분 -> 모니터의 condition variable과 관련된 부분





### 큐 두가지

1. entry queue : mutex에 의해 관리. critical section에 진입을 기다리는 큐
2. waiting queue : condition variable에 의해 관리. 조건이 충족되길 기다리는 큐





## 🚀 JAVA에서 모니터 - 작성 중

모니터는 보통 프로그래밍 언어 레벨에서 지원되기 때문에 직접 구현할 일은 없다.

개발자는 지원되는 모니터 기능을 이용하면 된다.



JAVA에서 모든 객체는 내부적으로 모니터를 **하나**만 가진다.



모니터에서 제공하는 mutual exclusion 기능은 synchronized 키워드로 사용한다.

또만, 자바의 모니터는 condition variable을 **하나**만 가진다.



자바 모니터의 세 가지 동작

1. wait
2. notify == signal
3. notify all == broadcast







## 🔍 참고

[https://www.youtube.com/watch?v=gTkvX2Awj6g\&ab\_channel=%EC%89%AC%EC%9A%B4%EC%BD%94%EB%93%9C](https://www.youtube.com/watch?v=gTkvX2Awj6g\&ab\_channel=%EC%89%AC%EC%9A%B4%EC%BD%94%EB%93%9C)

[https://www.youtube.com/watch?v=Dms1oBmRAlo\&ab\_channel=%EC%89%AC%EC%9A%B4%EC%BD%94%EB%93%9C](https://www.youtube.com/watch?v=Dms1oBmRAlo\&ab\_channel=%EC%89%AC%EC%9A%B4%EC%BD%94%EB%93%9C)



